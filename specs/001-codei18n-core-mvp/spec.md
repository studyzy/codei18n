# 功能规范: CodeI18n Core MVP - 代码注释国际化基础设施

**功能分支**: `001-codei18n-core-mvp`
**创建时间**: 2025-12-15
**状态**: 草稿
**输入**: 用户描述: "通过README.md应该能够很清楚知道本项目要干什么了，主要要注意的是当前项目不包括插件部分，VSCode插件和JetBrains插件在另外仓库区实现。现在代码量是0，我需要从零到一的建立起这个项目。需要增加翻译模块，支持Google翻译API和类似OpenAI API的LLM API来实现中英文互译。"

## 用户场景与测试 *(必填)*

### 场景 0 - IDE 插件集成基础 (优先级: P0)

作为 IDE 插件开发者（VS Code/JetBrains），我希望 CodeI18n CLI 能够作为稳定、高效的后端进程运行，通过标准输入输出与 IDE 插件通信，以便在不重新实现核心逻辑的情况下开发插件。

**优先级原因**: 这是一个架构级约束。如果 CLI 设计不考虑 IDE 集成（如不支持 Stdin 或混合输出日志），后续的插件开发将非常困难甚至不可行。

**独立测试**:
1. 通过管道将文件内容传输给 CLI (`cat file.go | codei18n scan --stdin --file file.go`)，验证能否正确解析未保存的内容。
2. 运行命令并重定向 stdout 到文件，验证文件中仅包含合法的 JSON 数据，没有任何日志干扰（日志应在 stderr）。
3. 验证单次调用 (`scan --with-translations`) 能否获取渲染所需的所有数据，无需 N+1 次查询。

**验收场景**:
1. **给定** 一个未保存的 Go 文件缓冲区内容，**当** 通过 Stdin 传递给 CLI 并指定 `--stdin`，**那么** CLI 能够解析内容并返回正确的注释位置和 ID
2. **给定** CLI 正在运行扫描，**当** 发生错误或输出日志时，**那么** 所有非 JSON 内容都写入 stderr，stdout 保持纯净的 JSON
3. **给定** 插件需要显示翻译，**当** 调用 `scan --with-translations`，**那么** 返回的 JSON 中包含已翻译的文本

### 用户故事 1 - Go 代码注释扫描与 ID 生成 (优先级: P1)

作为开发者，我希望工具能够扫描 Go 源代码文件，提取所有注释并为每个注释生成稳定的语义 ID，以便后续的多语言映射能够准确追踪每条注释，即使代码重构也不会丢失映射关系。

**优先级原因**: 这是整个系统的基石。没有稳定的注释 ID 和 AST 解析能力，后续的翻译和映射功能都无法实现。这是 MVP 的核心能力。

**独立测试**: 可以通过准备包含各种注释类型（行注释、块注释、文档注释）的 Go 测试文件，运行 CLI 扫描命令，验证输出的 JSON 包含所有注释及其稳定 ID。即使代码重构（如重命名函数、调整位置），相同注释的 ID 应保持不变。

**验收场景**:

1. **给定** 一个包含多种注释的 Go 源文件，**当** 开发者运行 `codei18n scan --file main.go --format json` 命令，**那么** 系统输出 JSON 格式的注释列表，每条注释包含 ID、文件路径、符号位置、注释文本
2. **给定** 一个 Go 文件中的函数注释，**当** 开发者重命名函数但保持注释内容不变，**那么** 重新扫描后该注释的 ID 保持稳定不变
3. **给定** 一个包含中英文混合注释的 Go 文件，**当** 运行扫描命令，**那么** 系统能够正确识别和提取所有注释，不受语言影响
4. **给定** 一个包含嵌套结构体的 Go 文件，**当** 运行扫描，**那么** 系统能够正确绑定注释到对应的语义符号（包、结构体、方法、字段等）

---

### 用户故事 2 - 注释多语言映射管理 (优先级: P1)

作为开发者，我希望能够为每条注释创建和管理多语言映射（中文↔英文），并将映射数据存储在本地文件中，以便在 Git 提交前进行注释语言转换。

**优先级原因**: 映射管理是实现"单一语言源"原则的关键。开发者需要能够维护本地的多语言注释映射，这是连接本地开发和 Git 仓库的桥梁。

**独立测试**: 可以通过创建包含中文注释的 Go 文件，使用 CLI 工具扫描并生成映射文件，验证 `.codei18n/` 目录下生成的映射 JSON 文件格式正确，包含注释 ID 和多语言文本对。修改映射文件后，能够重新加载并应用到源码转换中。

**验收场景**:

1. **给定** 扫描后的注释列表，**当** 开发者运行 `codei18n map create --source-lang zh-CN --target-lang en`，**那么** 系统在 `.codei18n/` 目录创建映射文件，包含所有注释的 ID 和待翻译的占位符
2. **给定** 一个已存在的映射文件，**当** 开发者手动编辑添加英文翻译，**那么** 系统能够加载并验证映射文件格式正确
3. **给定** 注释 ID 和对应的中英文文本，**当** 开发者查询映射，**那么** 系统能够快速返回指定语言的注释文本
4. **给定** 映射文件损坏或格式错误，**当** 系统加载映射，**那么** 提供清晰的中文错误提示，指出具体问题位置

---

### 用户故事 3 - 自动翻译集成 (优先级: P2)

作为开发者，我希望能够使用 Google 翻译 API 或 OpenAI 兼容的 LLM API 自动翻译映射文件中的注释，以便快速完成大量注释的国际化工作，减少人工翻译成本。

**优先级原因**: 虽然手动翻译可行，但对于存量代码库，自动翻译能显著提高效率。这是提升用户体验的关键功能。

**独立测试**: 配置有效的 API Key（Google Translate 或 OpenAI），运行翻译命令，验证未翻译的注释被自动填充了翻译内容。验证翻译结果的准确性和 API 调用的稳定性。

**验收场景**:

1. **给定** 包含未翻译条目的映射文件和有效的 Google Translate API Key，**当** 运行 `codei18n translate --provider google`，**那么** 未翻译的注释被自动翻译并填充
2. **给定** 包含未翻译条目的映射文件和有效的 OpenAI API Key及配置，**当** 运行 `codei18n translate --provider openai --model gpt-3.5-turbo`，**那么** 未翻译的注释被 LLM 翻译并填充，且翻译风格符合代码上下文
3. **给定** 网络连接失败或 API Key 无效，**当** 运行翻译命令，**那么** 系统报错并跳过翻译，不破坏现有映射文件
4. **给定** 配置文件中设置了翻译提供商，**当** 运行 `codei18n translate` 不带参数，**那么** 使用默认配置进行翻译

---

### 用户故事 4 - Git 提交前注释语言自动转换 (优先级: P2)

作为开发者，我希望在执行 Git 提交时，pre-commit hook 能够自动检测源码中的中文注释，并根据映射文件将其转换为英文，确保提交到仓库的代码始终是英文注释。

**优先级原因**: 这是实现"零 Git 污染"的核心功能。虽然重要，但在有基础的扫描和映射能力后才能实现，因此优先级为 P2。

**独立测试**: 可以通过在 Git 仓库中配置 pre-commit hook，编写包含中文注释的代码，执行 `git commit`，验证提交前源码中的中文注释已自动转换为英文，且 Git 历史中只包含英文注释。

**验收场景**:

1. **给定** 一个配置了 pre-commit hook 的 Git 仓库，**当** 开发者提交包含中文注释的 Go 文件，**那么** hook 自动将中文注释转换为英文后再提交
2. **给定** 某条注释没有对应的英文翻译映射，**当** 尝试提交，**那么** hook 阻止提交并提示开发者补充翻译（或提示运行自动翻译）
3. **给定** 多个文件包含中文注释，**当** 批量提交，**那么** 所有文件的注释都被正确转换，且转换时间在 5 秒内完成
4. **给定** 提交被 hook 阻止，**当** 开发者补充翻译后重新提交，**那么** 提交成功且 Git 历史中只有英文注释

---

### 用户故事 5 - CLI 注释语言双向转换 (优先级: P2)

作为开发者，我希望通过 CLI 命令手动将源码中的注释在中英文之间双向转换，以便在不同场景下（如代码审查、本地调试）切换注释语言。

**优先级原因**: 提供手动控制能力，增强工具的灵活性。但不是 MVP 的必需功能，可以在 P1 功能完成后添加。

**独立测试**: 可以通过准备一个英文注释的 Go 文件和完整的映射文件，运行 `codei18n convert --file main.go --to zh-CN`，验证文件中的注释被转换为中文。再运行 `--to en` 转换回英文，验证可逆性。

**验收场景**:

1. **给定** 一个包含英文注释的 Go 文件和映射文件，**当** 开发者运行 `codei18n convert --file main.go --to zh-CN`，**那么** 文件中的注释被转换为中文
2. **给定** 一个包含中文注释的文件，**当** 运行 `codei18n convert --to en`，**那么** 注释被转换为英文，且内容与原始英文一致（可逆性）
3. **给定** 整个项目目录，**当** 运行 `codei18n convert --dir . --to zh-CN`，**那么** 所有 Go 文件的注释被批量转换
4. **给定** 转换过程中发现未映射的注释，**当** 转换执行，**那么** 系统跳过未映射注释并在日志中记录，允许部分转换成功

---

### 用户故事 6 - 项目初始化与配置管理 (优先级: P3)

作为开发者，我希望能够通过简单的命令初始化 CodeI18n 项目配置，设置源语言、目标语言、翻译提供商配置等，以便快速开始使用工具。

**优先级原因**: 提升用户体验，但不是核心功能。可以通过手动创建配置文件实现，因此优先级较低。

**独立测试**: 可以在空项目中运行 `codei18n init`，验证生成 `.codei18n/config.json` 配置文件。

**验收场景**:

1. **给定** 一个没有 CodeI18n 配置的 Go 项目，**当** 开发者运行 `codei18n init`，**那么** 在项目根目录创建 `.codei18n/` 目录和 `config.json` 配置文件
2. **给定** 初始化后的配置文件，**当** 开发者修改 `sourceLanguage` 为 `en` 和 `localLanguage` 为 `zh-CN`，**那么** 后续的扫描和转换命令自动使用这些配置
3. **给定** 配置文件包含无效的语言代码，**当** 运行任何 CLI 命令，**那么** 提供清晰的中文错误提示
4. **给定** 配置文件不存在，**当** 运行扫描或转换命令，**那么** 使用合理的默认值（en/zh-CN）并提示开发者运行 `init`

---

### 边界情况

- **大文件处理**: 当 Go 文件超过 10000 行且包含数千条注释时，扫描性能如何？系统应在 1 秒内完成扫描。
- **Unicode 处理**: 当注释包含 emoji、特殊 Unicode 字符时，系统能否正确解析和保存？
- **文件编码**: 当 Go 文件使用非 UTF-8 编码时，系统如何检测并提示错误？
- **并发安全**: 当多个开发者同时修改映射文件时，如何避免冲突？（合理默认：映射文件是本地的，不提交到 Git，各开发者维护自己的映射）
- **注释格式边缘情况**: 系统如何处理注释中的代码示例、Markdown 格式、特殊标记（如 TODO、FIXME）？
- **AST 解析失败**: 当 Go 文件包含语法错误导致 AST 解析失败时，系统应提供清晰的错误提示，而不是崩溃。
- **翻译 API 限制**: 当翻译 API 达到速率限制或网络超时，系统应优雅失败，保留原有内容，并提示用户。
- **Hook 执行失败**: 当 pre-commit hook 因为缺少依赖或权限问题无法执行时，如何优雅降级？

## 需求 *(必填)*

### 功能需求

#### 核心引擎需求

- **FR-001**: 系统必须使用 Go 标准库的 `go/parser` 和 `go/ast` 解析 Go 源代码，提取所有注释（行注释 `//`、块注释 `/* */`、文档注释）
- **FR-002**: 系统必须为每条注释生成稳定的唯一 ID，ID 计算基于文件路径、编程语言、父符号和标准化的注释文本的 SHA1 哈希
- **FR-003**: 系统必须将注释绑定到具体的语义符号（包声明、函数、类型、结构体字段、方法等），而非行号
- **FR-004**: 系统必须支持增量扫描，只处理自上次扫描后修改的文件
- **FR-005**: 系统必须在扫描单个 Go 文件（< 1000 行）时，处理时间不超过 100ms

#### CLI 工具需求

- **FR-006**: 系统必须提供 `scan` 命令，支持 `--file` 参数指定单个文件，或 `--dir` 参数扫描整个目录
- **FR-007**: 系统必须支持 `--format` 参数，输出格式包括 `json`（机器可读）和 `table`（人类可读）
- **FR-008**: 系统必须提供 `map` 命令，用于创建、查询和更新注释的多语言映射
- **FR-009**: 系统必须提供 `convert` 命令，支持 `--to` 参数指定目标语言（en/zh-CN），执行注释语言转换
- **FR-010**: 系统必须提供 `init` 命令，初始化项目配置，创建 `.codei18n/config.json` 文件
- **FR-011**: CLI 工具必须将正常输出写入 stdout，错误信息写入 stderr，以支持管道操作
- **FR-012**: CLI 工具必须提供 `--help` 参数，显示完整的中文帮助文档
- **FR-013**: 系统必须提供 `translate` 命令，调用配置的翻译引擎自动填充映射文件中的缺失翻译

#### 翻译引擎需求 (新增)

- **FR-014**: 系统必须定义通用的 `Translator` 接口，支持多种翻译后端
- **FR-015**: 系统必须实现 `GoogleTranslator`，集成 Google Translate API
- **FR-016**: 系统必须实现 `LLMTranslator`，集成 OpenAI 兼容的 API (支持自定义 Endpoint, Model, Key)
- **FR-017**: 系统必须支持通过环境变量（推荐）或配置文件读取 API Key，避免硬编码
- **FR-018**: 翻译过程必须支持批量处理或并发控制，以提高效率并遵守 API 速率限制

#### 映射管理需求

- **FR-019**: 系统必须将映射数据存储在 `.codei18n/mappings.json` 文件中，格式为 JSON
- **FR-020**: 映射文件必须包含版本号、源语言、目标语言和注释映射字典
- **FR-021**: 系统必须支持快速查询映射，给定注释 ID 和目标语言，返回翻译文本的时间不超过 10ms
- **FR-022**: 系统必须在映射文件损坏时，提供详细的错误提示和恢复建议
- **FR-023**: 系统必须支持映射文件的备份和还原功能

#### Git 集成需求

- **FR-024**: 系统必须提供 pre-commit hook 脚本，在 Git 提交前自动检测和转换注释语言
- **FR-025**: pre-commit hook 必须只处理 staged 文件，不影响未 staged 的文件
- **FR-026**: pre-commit hook 在处理少于 50 个文件时，执行时间不超过 5 秒
- **FR-027**: 当注释缺少翻译映射时，pre-commit hook 必须阻止提交并提供清晰的中文错误提示
- **FR-028**: 系统必须提供 hook 安装命令 `codei18n hook install`，自动配置 Git hooks

#### 配置管理需求

- **FR-029**: 系统必须支持通过 `.codei18n/config.json` 文件配置源语言、目标语言、翻译提供商等
- **FR-030**: 系统必须支持配置文件中的 `excludePatterns` 字段，排除特定文件或目录
- **FR-031**: 当配置文件不存在时，系统必须使用合理的默认值（sourceLanguage: "en", localLanguage: "zh-CN"）

### 关键实体

- **Comment（注释）**: 表示从源码中提取的单条注释，包含属性：
  - `ID` (string): 稳定的唯一标识符，基于语义计算
  - `File` (string): 文件路径（相对于项目根目录）
  - `Language` (string): 编程语言（如 "go"）
  - `Symbol` (string): 注释绑定的语义符号（如 "package.main.CalculateBalance"）
  - `Range` (TextRange): 注释在源码中的位置（起始行列、结束行列）
  - `SourceText` (string): 注释的原始文本
  - `Type` (string): 注释类型（"line", "block", "doc"）

- **LocalizedComment（本地化注释）**: 表示注释的多语言翻译，包含属性：
  - `CommentID` (string): 引用的注释 ID
  - `Lang` (string): 语言代码（如 "en", "zh-CN"）
  - `Text` (string): 翻译后的文本

- **Mapping（映射）**: 表示整个项目的注释多语言映射集合，包含属性：
  - `Version` (string): 映射文件格式版本
  - `SourceLanguage` (string): 源语言代码
  - `TargetLanguage` (string): 目标语言代码
  - `Comments` (map[string]map[string]string): 注释 ID → 语言代码 → 翻译文本的嵌套映射

- **Config（配置）**: 表示项目级配置，包含属性：
  - `SourceLanguage` (string): 仓库中的注释语言
  - `LocalLanguage` (string): 本地开发使用的注释语言
  - `ExcludePatterns` ([]string): 排除的文件模式列表
  - `TranslationProvider` (string): 翻译服务提供商 ("google" 或 "openai")
  - `TranslationConfig` (map[string]string): 翻译服务的具体配置（如 Model, Endpoint 等，API Key 除外）

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: 开发者可以在 5 分钟内通过 CLI 完成项目初始化、扫描第一个 Go 文件并查看注释列表
- **SC-002**: 系统能够在 1 秒内扫描包含 100 个文件、总计 10000 行代码的 Go 项目
- **SC-003**: pre-commit hook 能够在 5 秒内处理包含 50 个修改文件的提交
- **SC-004**: 注释 ID 在代码重构（重命名函数、移动文件）后保持稳定性达到 95% 以上
- **SC-005**: 开发者在使用工具 1 周后，能够无需查阅文档即可完成常见操作（扫描、转换、提交）
- **SC-006**: CLI 工具的错误提示清晰度达到 90%（开发者无需额外查询即可理解和解决问题）
- **SC-007**: 自动翻译功能在网络正常情况下，成功率达到 99%

### 质量门槛（CodeI18n 项目要求）

- **QG-001**: 单元测试覆盖率达到 60% 以上
- **QG-002**: 核心模块（comment、mapping、translate）测试覆盖率达到 80% 以上
- **QG-003**: 所有代码通过 `gofmt` 格式化
- **QG-004**: 所有代码通过 `golint` 或 `staticcheck` 检查
- **QG-005**: 所有公共函数和类型有中文 GoDoc 注释
- **QG-006**: 所有文档使用中文编写

## 假设与约束

### 假设

1. **Go 版本**: 假设开发者使用 Go 1.25+ 版本
2. **文件编码**: 假设所有 Go 源文件使用 UTF-8 编码
3. **Git 使用**: 假设项目使用 Git 进行版本控制
4. **单仓库**: 假设一个 Git 仓库对应一个 CodeI18n 配置
5. **网络连接**: 假设使用自动翻译功能时，开发环境可以访问 Google Translate API 或 LLM API
6. **API Key**: 假设开发者拥有有效的翻译 API Key
7. **IDE 集成**: 假设 IDE 插件将通过子进程（Child Process）方式调用 CLI，并通过 Stdin/Stdout 通信

### 约束

1. **范围限制**: 本 MVP 仅支持 Go 语言
2. **IDE 插件排除**: 本项目不包括 VS Code 和 JetBrains IDE 插件的实现（但必须为它们提供 CLI 支持）
3. **并发控制**: 不处理多开发者同时修改映射文件的冲突
4. **性能优化**: MVP 不包括大规模项目的性能优化，但需满足基本性能要求
5. **国际化**: CLI 输出和错误信息仅支持中文
6. **输出纯净性**: JSON 输出模式下，Stdout 必须严格只包含 JSON 数据，禁止输出任何日志信息

## 非功能需求

### 性能

- 单文件扫描（< 1000 行）：< 100ms
- 项目扫描（100 文件，10000 行）：< 1s
- 映射查询：< 10ms
- pre-commit hook（50 文件）：< 5s
- 自动翻译：依赖外部 API 响应速度，但在本地处理层面应无显著延迟

### 可靠性

- AST 解析失败时提供清晰错误提示，不崩溃
- 映射文件损坏时能够检测并提供恢复建议
- 命令执行失败时返回非零退出码
- 翻译 API 失败时，不影响其他核心功能的使用

### 可维护性

- 所有代码遵循 Effective Go 规范
- 核心模块（comment、mapping、translate）保持独立，可单独测试
- CLI 命令与核心逻辑解耦
- 使用依赖注入模式，便于测试和扩展

### 可扩展性

- 设计语言适配器接口，便于后续添加 Rust、JavaScript 等语言支持
- 翻译引擎设计为可插拔，便于集成更多服务
- 映射文件格式支持版本控制，便于未来升级

## 技术考虑（非实现细节）

### AST 解析策略

- 使用 Go 标准库 `go/parser` 和 `go/ast`
- 注释必须绑定到 AST 节点，而非通过行号定位
- 支持嵌套结构（包 → 类型 → 方法 → 字段）的注释提取

### 注释 ID 稳定性保证

- ID 计算不依赖行号和列号
- ID 计算包含父符号的完整路径
- 注释文本标准化（去除前导空格、统一换行符）后再计算哈希

### 翻译提供商策略

- 定义统一的 `Translator` 接口
- 实现 `GoogleTranslator` (REST API)
- 实现 `LLMTranslator` (OpenAI-compatible REST API)
- 考虑简单的内存缓存或文件缓存，减少重复翻译 API 调用

### 映射文件设计

- 使用 JSON 格式存储
- 扁平化结构
- 包含版本号

### CLI 设计原则

- 遵循 Unix 哲学
- 支持管道操作
- 提供 `--json` 输出
- 命令命名清晰（scan, map, convert, translate, init, hook）

## 依赖关系

- Go 1.25+ 运行时
- Git 2.0+
- 标准 Unix/Linux/macOS 文件系统
