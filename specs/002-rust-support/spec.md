# 功能规范: Rust 语言支持

**功能分支**: `002-rust-support`
**创建时间**: 2025-12-17
**状态**: 草稿
**输入**: 用户描述: "当前项目已经能够支持Golang的注释的翻译和替换，接下来我希望增强，能够支持Rust语言的注释提取、翻译和替换"

## 用户场景与测试 *(必填)*

### 用户故事 1 - 提取 Rust 注释 (优先级: P1)

作为一名开发者，我希望能够扫描 Rust 源代码文件并提取出其中的注释，以便后续进行翻译。

**优先级原因**: 这是实现翻译和替换的基础。

**独立测试**: 编写包含各种类型 Rust 注释（行注释、块注释、文档注释）的测试文件，运行提取逻辑，验证输出的 JSON 结构是否包含所有预期注释及其上下文信息。

**验收场景**:

1. **给定** 一个包含 `//` 行注释的 Rust 文件, **当** 运行扫描命令时, **那么** 应提取出该注释及其位置信息。
2. **给定** 一个包含 `///` 文档注释的 Rust 文件, **当** 运行扫描命令时, **那么** 应提取出文档注释，且归属于下方的代码符号（如函数或结构体）。
3. **给定** 一个包含 `/*! ... */` 块级文档注释的 Rust 文件, **当** 运行扫描命令时, **那么** 应正确提取内容。
4. **给定** 一个包含 `//!` 模块级注释的 Rust 文件, **当** 运行扫描命令时, **那么** 应提取该注释并标记为模块级。

---

### 用户故事 2 - 生成稳定的 Rust 注释 ID (优先级: P1)

作为系统，我需要为提取的 Rust 注释生成稳定的唯一 ID，以便在代码格式化或微调时保持翻译映射的有效性。

**优先级原因**: 只有 ID 稳定，翻译结果才能持久化复用，符合“语义优先”原则。

**独立测试**: 对同一 Rust 文件进行格式化（如增加空格、换行），验证生成的注释 ID 保持不变。

**验收场景**:

1. **给定** 一个 Rust 函数及其文档注释, **当** 在函数体内部增加空行并重新扫描时, **那么** 文档注释的 ID 应保持不变。
2. **给定** 一个 Rust 结构体, **当** 改变其在文件中的行号（如在上方插入新代码）时, **那么** 结构体上的注释 ID 应保持不变。

---

### 用户故事 3 - 翻译并应用 Rust 注释 (优先级: P1)

作为一名开发者，我希望能够将 Rust 代码中的注释翻译为本地语言，并能在“原文”和“译文”之间切换（或生成译文视图），以便更好地阅读代码。

**优先级原因**: 交付用户最终价值的核心功能。

**独立测试**: 模拟翻译 API 返回结果，验证能够正确生成包含译文的输出，或正确更新映射文件。

**验收场景**:

1. **给定** 已提取的 Rust 注释和对应的翻译映射, **当** 请求生成翻译后的代码或视图时, **那么** 能够看到用本地语言显示的注释。
2. **给定** 本地语言的注释, **当** 请求还原或替换回英文时, **那么** 代码应恢复为原始的英文注释状态（基于 Git 或备份）。

---

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须支持解析 `.rs` 文件。
- **FR-002**: 系统必须支持提取以下类型的 Rust 注释：
    - 行注释 `//`
    - 块注释 `/* ... */`
    - 外部文档注释 `///` 和 `/** ... */`
    - 内部文档注释 `//!` 和 `/*! ... */`
- **FR-003**: 系统必须能够识别注释所属的语义符号（Parent Symbol），包括：
    - Function (`fn`)
    - Struct (`struct`)
    - Enum (`enum`)
    - Trait (`trait`)
    - Implementation (`impl`)
    - Module (`mod`)
    - Macro invocation (部分支持)
- **FR-004**: 系统必须使用 **Tree-sitter** (通过 CGO 集成) 来解析 Rust 代码以确保准确性（非正则）。
- **FR-005**: 系统必须按照统一的 ID 生成算法（File + Symbol + Content）为 Rust 注释生成 ID。
- **FR-006**: 系统必须支持将翻译后的注释回写到 Rust 源文件中（替换模式）或生成 IDE 提示所需的 JSON 数据（无侵入模式）。

### 边界情况

- **宏定义 (Macros)**: 对于 `macro_rules!` 或过程宏内部的注释，如果无法准确解析其语义上下文，系统应将其视为普通文本注释处理，或者优雅地跳过，避免 ID 不稳定。
- **字符串字面量**: 必须正确处理包含 `//` 或 `/*` 的字符串字面量，不应将其误识别为注释。
- **语法错误**: 如果 Rust 文件存在语法错误导致无法完全解析，系统应尽可能提取可识别部分的注释，或报错提示用户。
- **非 UTF-8 编码**: 虽然 Rust 强制 UTF-8，但如果遇到无效编码文件，应报错跳过。

### 关键实体

- **RustAdapter**: 实现 `LanguageAdapter` 接口，负责 Rust 文件的解析和提取。
- **RustSymbol**: 描述 Rust 代码中的语义符号，用于构建上下文路径（如 `my_mod::MyStruct::my_fn`）。

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: 支持 Rust 2021 版本的所有标准注释语法。
- **SC-002**: 对标准 Rust 项目（如包含 100+ 文件的 crate）的扫描速度在 5 秒内完成。
- **SC-003**: 格式化代码（运行 `cargo fmt`）后，95% 以上的注释 ID 保持不变。

### 质量门槛（CodeI18n 项目要求）

- **QG-001**: 单元测试覆盖率达到 60% 以上
- **QG-002**: 核心模块（comment、mapping、translate）测试覆盖率达到 80% 以上
- **QG-003**: 所有代码通过 `gofmt` 格式化
- **QG-004**: 所有代码通过 `golint` 或 `staticcheck` 检查
- **QG-005**: 所有公共函数和类型有中文 GoDoc 注释
- **QG-006**: 所有文档使用中文编写
