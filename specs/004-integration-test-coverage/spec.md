# 功能规范: Integration Test Coverage

**功能分支**: `004-integration-test-coverage`
**创建时间**: 2025-12-17
**状态**: 草稿
**输入**: 用户描述: "我希望对这个程序进行集成测试，覆盖codei18n的各个功能"

## 用户场景与测试 *(必填)*

<!--
  重要说明: 用户故事应按重要性排序, 作为用户旅程进行优先级划分.
-->

### 用户故事 1 - 基础扫描与翻译流程验证 (优先级: P1)

作为开发者，我希望运行集成测试来验证 `scan` 命令能够正确解析源代码、生成注释 ID 并输出翻译结果（使用 Mock 翻译服务），以确保核心工作流未被破坏。

**优先级原因**: 这是 CodeI18n 的核心功能，任何回归都会导致工具不可用。

**独立测试**: 可以通过创建一个包含样例 Go 代码的临时目录，运行 CLI 命令，并断言输出结果和副作用（如生成的映射文件）来独立测试。

**验收场景**:

1. **给定** 一个包含英文注释的 Go 源文件和一个配置为使用 Mock 翻译器的配置文件
2. **当** 运行 `codei18n scan --file sample.go --lang zh-CN --format json` 时
3. **那么** 命令应成功退出（代码 0）
4. **并且** 输出的 JSON 应包含源文件的所有注释及其（Mock 的）翻译结果
5. **并且** 本地映射文件（如 `.codei18n/mapping.json`）应被正确创建或更新

---

### 用户故事 2 - 配置加载与覆盖验证 (优先级: P2)

作为开发者，我希望测试系统能够正确加载 `.codei18n/config.json` 中的配置，并允许通过 CLI 参数覆盖这些配置，以确保用户自定义设置生效。

**优先级原因**: 确保用户配置的灵活性和正确性是工具可用性的关键。

**独立测试**: 可以通过创建不同的配置文件和运行带有不同参数的 CLI 命令来测试。

**验收场景**:

1. **给定** 一个配置文件指定 `sourceLanguage: "en"`, `targetLanguage: "ja"`
2. **当** 运行 `codei18n scan` （不带参数）时
3. **那么** 系统应默认使用日语作为目标语言进行处理
4. **当** 运行 `codei18n scan --lang zh-CN` 时
5. **那么** 系统应忽略配置文件中的日语设置，使用中文作为目标语言

---

### 用户故事 3 - 幂等性与增量更新验证 (优先级: P2)

作为开发者，我希望验证多次运行 `scan` 命令不会产生副作用（如重复条目），且能正确处理新增的注释，以确保在持续开发过程中的稳定性。

**优先级原因**: 防止映射文件膨胀和数据不一致。

**独立测试**: 对同一文件连续运行多次命令，并在中间修改源文件。

**验收场景**:

1. **给定** 已经运行过一次 `scan` 并生成了映射文件的环境
2. **当** 再次对未修改的文件运行 `scan` 时
3. **那么** 映射文件内容应保持不变
4. **当** 在源文件中添加新注释并再次运行 `scan` 时
5. **那么** 映射文件应仅增加新注释的条目，旧条目保持不变

---

### 用户故事 4 - Go 语言复杂注释场景覆盖 (优先级: P2)

作为开发者，我希望验证解析器能够正确处理 Go 语言中的各种复杂注释形式，包括连续多行注释、块注释、文档注释以及被注释掉的代码，以确保翻译功能不会错误地处理这些内容。

**优先级原因**: 真实代码库中注释形式多样，必须确保解析器鲁棒性。

**独立测试**: 构造包含所有这些边缘情况的 `complex_fixtures.go` 文件并运行扫描。

**验收场景**:

1. **给定** 一个包含以下内容的 Go 文件：
    - 连续的多行 `//` 注释（应被合并或分别处理，视策略而定）
    - 行内混合注释 `code(); // comment`
    - 块注释 `/* ... */`
    - 被注释掉的代码 `// code();` （应作为普通文本提取，或根据配置忽略）
2. **当** 运行 `scan` 命令时
3. **那么** 输出结果应正确提取所有有效注释
4. **并且** 注释的 `Range` 属性应准确对应源文件位置
5. **并且** 连续的单行注释组应被正确识别为关联的注释块（如果支持）

---

### 用户故事 5 - Rust 语言多语言支持验证 (优先级: P2)

作为开发者，我希望验证工具对 Rust 语言文件的支持，包括其特有的文档注释语法，以确保多语言扩展能力正常工作。

**优先级原因**: 验证架构的多语言扩展性。

**独立测试**: 使用包含 Rust 特有注释语法的 `.rs` 文件进行测试。

**验收场景**:

1. **给定** 一个包含 Rust 代码的文件，其中有：
    - 外部文档注释 `/// Outer doc`
    - 内部文档注释 `//! Inner doc`
    - 普通行注释 `// Line comment`
    - 块注释 `/* Block */`
2. **当** 运行 `scan --file lib.rs` 时
3. **那么** 系统应能自动检测语言为 Rust（或通过扩展名识别）
4. **并且** 输出中应包含上述所有类型的注释
5. **并且** 注释类型（Type）字段应能正确区分文档注释和普通注释

---

### 边界情况

- 当源文件包含语法错误时，CLI 应报错并提示解析失败，而不是崩清。
- 当配置文件格式错误（如非法 JSON）时，应使用默认配置或报错提示。
- 当映射文件损坏时，应尝试修复或报错，而不是覆盖导致数据丢失。
- 当处理空文件或无注释文件时，应正常退出并输出空结果。
- 当遇到被注释掉的代码时，解析器应将其视为普通注释文本提取（不进行特殊语义分析）。

## 需求 *(必填)*

### 功能需求

- **FR-001**: 集成测试套件必须能够通过项目的标准测试命令运行（例如标准 Go 测试工具链）。
- **FR-002**: 测试环境必须能够隔离文件系统操作，确保测试之间互不干扰。
- **FR-003**: 系统必须支持确定性的翻译模拟模式，以便在离线状态下进行测试且结果可预测。
- **FR-004**: 测试必须覆盖 CLI 的主要功能选项，包括文件指定、语言选择、输出格式等。
- **FR-005**: 必须验证 JSON 输出格式符合 IDE 插件所期望的 Schema。
- **FR-006**: 测试必须验证 `.codei18n` 目录和映射文件的创建与读写权限处理。
- **FR-007**: 必须提供包含复杂 Go 注释（连续行、块、行内）的测试夹具（Fixtures）。
- **FR-008**: 必须提供包含 Rust 特有注释（///, //!）的测试夹具，并验证其解析正确性。

### 关键实体 *(如果功能涉及数据则包含)*

- **TestFixture**: 用于测试的样例代码文件集合（Go 源文件和 Rust 源文件）。
- **MockTranslator**: 模拟翻译服务的组件，对于固定输入返回固定输出。
- **TempWorkspace**: 测试执行期间的临时目录环境。

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: 集成测试能够覆盖 CLI `scan` 命令 100% 的支持参数。
- **SC-002**: 在本地环境下，完整集成测试套件的运行时间不超过 30 秒（使用 Mock）。
- **SC-003**: 能够成功模拟并验证“首次扫描”、“二次扫描（无变化）”、“增量扫描（有变化）”三种场景。

### 质量门槛（CodeI18n 项目要求）

- **QG-001**: 单元测试覆盖率达到 60% 以上
- **QG-002**: 核心模块（comment、mapping、translate）测试覆盖率达到 80% 以上
- **QG-003**: 所有代码通过 `gofmt` 格式化
- **QG-004**: 所有代码通过 `golint` 或 `staticcheck` 检查
- **QG-005**: 所有公共函数和类型有中文 GoDoc 注释
- **QG-006**: 所有文档使用中文编写
